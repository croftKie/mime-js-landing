#!/usr/bin/env node
const HTML = require("html-parse-stringify");
const fs = require("fs");
const fse = require("fs-extra");

const mime = {
  render,
};

mime.render(createNodeMap());

// Loads HTML as an AST and returns the full HTML output or simply the HTML body for manipulation
function loadHTML(url, mode) {
  const data = fs.readFileSync(url, {
    encoding: "utf8",
    flag: "r",
  });
  const ast = HTML.parse(data);
  return mode === 0 ? ast[0].children[3].children : ast;
}

function createNodeMap() {
  const layout = _readLayoutMap();

  layout.forEach((e) => {
    e["templateTags"] = e.ids.map((id) => {
      try {
        // AST for template returned as array value
        const tags = _formatTags(`./echoes/templates/${id}.html`);
        return tags;
      } catch (err) {
        return null;
      }
    });
    e["headTags"] = e.ids.map((id) => {
      try {
        // AST for template returned as array value
        const tags = loadHTML(`./echoes/templates/${id}.html`, 1);
        const head_tags = tags[0].children[1].children.filter((child) => {
          if (child.name === "link") {
            child.attrs.href = _formatPath(child.attrs.href);
            return child;
          } else if (child.name === "script") {
            child.attrs.src = _formatPath(child.attrs.src);
            return child;
          }
        });
        return head_tags;
      } catch (err) {
        null;
      }
    });
  });

  return layout;
}

// renders element tree to DOM
function render(nodeMap) {
  _buildOutput();
  _copyPublic();
  nodeMap.forEach((map) => {
    const _content = _coreHTML();
    const head = _content[0].children[0];
    const body = _content[0].children[1];
    map.templateTags.forEach((template) => {
      if (template !== null) {
        template.forEach((tag) => {
          body.children.push(tag);
        });
      }
    });
    map.headTags.forEach((headTag) => {
      if (headTag !== null) {
        headTag.forEach((tag) => {
          head.children.push(tag);
        });
      }
    });
    _content[0].children[0] = head;
    _content[0].children[1] = body;

    const string = HTML.stringify(_content);

    try {
      fs.unlinkSync(`./dist/${map.fileName}.html`);
      fs.writeFileSync(`./dist/${map.fileName}.html`, string);
    } catch (err) {
      fs.writeFileSync(`./dist/${map.fileName}.html`, string);
    }
  });
}

function _buildOutput() {
  const path = "./dist";
  const publicFolder = "./dist/public";
  try {
    fs.accessSync(path, fs.constants.R_OK);
  } catch (err) {
    fs.mkdirSync(path);
    fs.mkdirSync(publicFolder);
  }
}

function _readLayoutMap() {
  const files = fs.readdirSync("./echoes/layouts/");
  const layoutFiles = files.map((file) => {
    return {
      fileName: file.replace(".html", ""),
    };
  });

  layoutFiles.forEach((file) => {
    const layoutTags = loadHTML(`./echoes/layouts/${file.fileName}.html`, 0);
    file["ids"] = layoutTags
      .filter((key) => {
        if (Object.keys(key).includes("attrs")) {
          return key.attrs.id;
        }
      })
      .map((item) => {
        return item.attrs.id;
      });
  });

  return layoutFiles;
}

function _coreHTML() {
  const data = fs.readFileSync(`./echoes/layouts/index.html`, {
    encoding: "utf8",
    flag: "r",
  });
  const head = HTML.parse(data)[0].children[1];
  traverse([head]);
  const string = HTML.stringify([head]);

  return HTML.parse(`<html lang="en">${string}<body></body></html>`);
}

function _copyPublic() {
  const src = "./public/";
  const dest = "./dist/public";
  console.log(src);
  try {
    fse.copySync(src, dest, { overwrite: true });
    console.log("success");
  } catch (err) {
    console.error(err);
  }
}

function _formatPath(path) {
  if (path.includes("../../public")) {
    return path.replace("../.", "");
  }

  if (path.includes("../layouts")) {
    return path.replace("../layouts", ".");
  }

  return path;
}

function _formatTags(path) {
  const tags = loadHTML(path, 0);
  traverse(tags);
  return tags;
}

function traverse(nodes) {
  const prepped = nodes.filter((obj) => {
    if ((obj.content && obj.content.includes("\r\n")) || obj.content === " ") {
      return;
    } else {
      return obj;
    }
  });

  prepped.forEach((node) => {
    if (node.attrs && node.attrs.src) {
      node.attrs.src = _formatPath(node.attrs.src);
    }
    if (node.attrs && node.attrs.href) {
      node.attrs.href = _formatPath(node.attrs.href);
    }
    if (node.children && node.children.length !== 0) {
      traverse(node.children);
    } else {
      return;
    }
  });
}
